package {	import com.facebook.graph.Facebook;		import flash.display.MovieClip;	import flash.events.*;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.net.Socket;	import flash.text.*;	import flash.ui.Keyboard;	import flash.utils.*;	public class Main2 extends MovieClip {				private var app_access_token:String = "204193593009336|cXkOeJLWnQg4p74kIGAa5OlVNGA"		private var sock:Socket = new Socket();						private var message:String;		private var message_type:String;		private var message_id:String;		private var last_message_id:String;		private var firstConnection:Boolean;			private var points:int;		private var usr_id:String;		private var usr_name:String;		private var coco_falling:Boolean;		private var coco_added:Boolean;		private var jumping:Boolean;		private var eating:Boolean;		var rightArrow:Boolean;		var leftArrow:Boolean;		var upArrow:Boolean;		var downArrow:Boolean;		var power:Number = 2;		var friction:Number = 0.95;		var yfriction:Number = 0.4;		var gravity:Number = 5;		var yspeed:Number = 0;		var xspeed:Number = 0;				//public var monster:Character;		public var coco:MovieClip;				public function Main2() {			trace(resultTxt);			/*resultTxt.appendText("Welcome ");			messageBox_txt.text="Pulsa para empezar"			click_btn.addEventListener(MouseEvent.MOUSE_DOWN,clicked);			eat_btn.addEventListener(MouseEvent.MOUSE_DOWN,eat);*/			Facebook.init("204193593009336",loginHandler);			prepareSocket();			firstConnection=true;			last_message_id="0";			coco_falling = false;			jumping = false;			eating = false;			// Create character instance			//monster = new Character();			//addChild(monster);						// Create character instance			coco = new cookie();			coco.addEventListener(MouseEvent.MOUSE_DOWN, eat)			stage.addEventListener(KeyboardEvent.KEY_DOWN, keyPressed);			stage.addEventListener(KeyboardEvent.KEY_UP, keyReleased);			//monster.addEventListener(Event.ENTER_FRAME, moveCharacter);			coco.addEventListener(Event.ENTER_FRAME, cocoFalls);			addChild(coco);			setChildIndex(coco, getChildIndex(monster)-1);			coco_added = true;		}				private function clicked(e:MouseEvent):void {			messageBox_txt.text="Starting!"			realTime();			click_btn.removeEventListener(MouseEvent.CLICK,clicked);		}				//Borrar, esto era para pinchar el coco y que se lo comiera pero ya no se pincha		private function eat(e:MouseEvent):void {			resultTxt.appendText('\nConectado?'+sock.connected);			/*if (!sock.connected){				initConnection();				}else{				resultTxt.appendText('\nStill connected-->Updating');			}*/			initConnection();			//sock.writeUTFBytes("Mensaje comido: "+message);			monster.eat();			removeChild(coco);			coco_added = false;			removeEventListener(MouseEvent.CLICK,clicked);		}						private function eatCoco():void {			resultTxt.appendText('\nConectado?'+sock.connected);			/*if (!sock.connected){			initConnection();				}else{			resultTxt.appendText('\nStill connected-->Updating');			}*/			initConnection();			//sock.writeUTFBytes("Mensaje comido: "+message);			monster.eat();			removeChild(coco);			coco_added = false;		}				protected function realTimeHandler(result:Object, fail:Object):void		{			messageBox_txt.text="entramos"			var myDate1:Date = new Date();			message_id = result[0].id;			//depending on the type of the post, the "Facebook saves the content of the message in a different place within the post"			message_type = result[0].type;			if (message_type=="status" || message_type=="question"){				if (result[0].message){					message = result[0].message;				}else{						message = result[0].story;				}				//If we have eaten the coco (it hasn't reached the floor) and there's no coco added, we add it				if (coco_added == false && message_id!=last_message_id){					coco = new cookie();					addChild(coco);					setChildIndex(coco, getChildIndex(monster)-1);					coco_added = true;					resultTxt.appendText('\nEl monstruo esta en:' + getChildIndex(monster));				}			}else if(message_type=="photo"){				if (result[0].message){					message = result[0].message;					}else if (result[0].caption){					message = result[0].caption;					}else{					message = result[0].story;					}				//If we have eaten the coco (it hasn't reached the floor) and there's no coco added, we add it				if (coco_added == false && message_id!=last_message_id){					coco = new chicken();					addChild(coco);					setChildIndex(coco, getChildIndex(monster)-1);					coco_added = true;					resultTxt.appendText('\nEl monstruo esta en:' + getChildIndex(monster));				}			}else if(message_type=="link"){				message = result[0].name;				//If we have eaten the coco (it hasn't reached the floor) and there's no coco added, we add it				if (coco_added == false && message_id!=last_message_id){					coco = new pizza();					addChild(coco);					setChildIndex(coco, getChildIndex(monster)-1);					coco_added = true;					resultTxt.appendText('\nEl monstruo esta en:' + getChildIndex(monster));				}			}else if (message_type=="video"){				if (result[0].message){					message = result[0].message;				}else{					message = result[0].name				}				//If we have eaten the coco (it hasn't reached the floor) and there's no coco added, we add it				if (coco_added == false && message_id!=last_message_id){					coco = new fries();					addChild(coco);					setChildIndex(coco, getChildIndex(monster)-1);					coco_added = true;					resultTxt.appendText('\nEl monstruo esta en:' + getChildIndex(monster));				}			}else{				message = "MESSAGE"				//If we have eaten the coco (it hasn't reached the floor) and there's no coco added, we add it				if (coco_added == false && message_id!=last_message_id){					coco = new cookie();					addChild(coco);					setChildIndex(coco, getChildIndex(monster)-1);					coco_added = true;					resultTxt.appendText('\nEl monstruo esta en:' + getChildIndex(monster));				}				}			messageBox_txt.text="Last message is: " + message_id + message + "\nLast update: "+ myDate1;							if (message_id!=last_message_id){				//muffins.fall_animation();				coco_falling = true;				last_message_id=message_id;				setChildIndex(coco, getChildIndex(monster)-1);			}			setTimeout(realTime ,5000);		}				protected function realTime():void{			/*if (!sock.connected){				initConnection();					}else{				resultTxt.appendText('\nStill connected-->Updating');			}*/			Facebook.api("/me/home",realTimeHandler,{limit:"1"});			if (firstConnection){				initConnection();								}		}				protected function loginHandler(success:Object,fail:Object):void{				if(success){					//Facebook.api("/me",getMeHandler);						//userImg.source=Facebook.getImageUrl(success.uid,"small");					Facebook.api("/me", getInfoHandler);					Facebook.api("/me/statuses",getStatusHandler);					//Facebook.api("/me/feed",getStatusHandler, {created_time:"1330537675"});				}		}				protected function getStatusHandler(result:Object, fail:Object):void{				resultTxt.appendText('\nYour last status: '+result[0].message);			}				protected function getInfoHandler(result:Object, fail:Object):void{				usr_id=result.id;				usr_name=result.name;				resultTxt.appendText(usr_name);			}				public function initConnection():void		{			//Poner la IP del router para probar desde fuera de casa y cambiarla tambien en la app de Facebook			//sock.connect('192.168.1.3', 2729);			sock.connect('localhost', 2729);		}				private function prepareSocket():void{						//What to do after serverSocket connects			//Mandamos $$$$#$ en todos los mensajes para indicar que es un mensaje interno del programa. Se elige ese código porque 			//se supone que no aparecerá en ningún mensaje de los que el usuario coma y por tanto no podrá confundirse			function connectingHandler(myStatus:Boolean):void{				if(myStatus){					resultTxt.appendText('\nConnected');					//sock.writeUTFBytes("ConnectedHere!");					//En la primera conexion preguntamos por los puntos					if (firstConnection){						sock.writeUTFBytes(usr_id);						sock.writeUTFBytes("$$$$#$userPoints#");						sock.flush();						firstConnection=false;						resultTxt.appendText('\nMensaje enviado al servidor: $userPoints#');												}else{						sock.writeUTFBytes(usr_id);						sock.writeUTFBytes("$$$$#Mensaje comido: "+message);						sock.writeUTFBytes("$$$$#"+message_id);						resultTxt.appendText('\nConectado?'+sock.connected);						sock.flush();						resultTxt.appendText('\nMensaje enviado al servidor: Mensaje comido');					}				}				else{					resultTxt.appendText('\nConnection failed');				}			}			sock.addEventListener(Event.CONNECT,connectingHandler);					//What to do when data is received			function receivingDataHandler(msg:String):void{				var message_received:String = sock.readUTFBytes(sock.bytesAvailable);				resultTxt.appendText('\nMessage received characteristics:' +msg);				resultTxt.appendText('\nServer response: ' +message_received);				//Actualizamos los puntos				if(int(message_received)!=0){					score.text = message_received;				}				//Actualizamos la info del juego				if(message_received.indexOf("ya se ha comido este mensaje")>=0){					game_info.text = message_received;					}else{					game_info.text = message;				}			}			sock.addEventListener(ProgressEvent.SOCKET_DATA,receivingDataHandler);						//What to do when socket is closed			function closingHandler():void{				sock.writeUTFBytes("$ClosingConnection$")				resultTxt.appendText('\nConnection Closed');				eating = false;			}			sock.addEventListener(Event.CLOSE,closingHandler);							//What to do when error is received			function ioErrorHandler(event:IOErrorEvent):void {				trace("ioErrorHandler: " + event);				resultTxt.appendText('\nIOError: '+event);			}			addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);			//What to do when security error is received			function securityErrorHandler(event:SecurityErrorEvent):void {				trace("securityErrorHandler: " + event);				resultTxt.appendText('\nSecurityError: '+event);			}			addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);		}						function keyPressed(event:KeyboardEvent):void{			if(event.keyCode == Keyboard.LEFT)			{				leftArrow = true;			}			if(event.keyCode == Keyboard.RIGHT)			{				rightArrow = true;			}			if(event.keyCode == Keyboard.UP)			{				jumping = true;				upArrow = true;			}			if(event.keyCode == Keyboard.DOWN)			{				downArrow = true;			}		}				function keyReleased(event:KeyboardEvent):void {			if (event.keyCode == Keyboard.RIGHT) {				rightArrow = false;			}			if (event.keyCode == Keyboard.LEFT) {				leftArrow = false;			}			if (event.keyCode == Keyboard.UP) {				upArrow = false;			}			if (event.keyCode == Keyboard.DOWN) {				downArrow = false;			}		}				function moveCharacter(event:Event):void {				if(monster.y == 0 && jumping){				jumping = false;			}			if(monster.hitTestObject(coco) && coco_falling && !eating){				eating = true;				coco_falling = false;				eatCoco();			}			//Let's check keys pressed			if (rightArrow) {				xspeed += power;			}			if (leftArrow) {				xspeed -= power;			}			if (upArrow && !jumping) {				yspeed -= 30;			}			if (downArrow) {				yspeed += power;			}						xspeed *= friction;			yspeed += gravity;			//Let's limit boundaries			//Ground boundary			if(monster.y>-yspeed){	//Si le voy a bajar más de lo que le queda por llegar al suelo 				if(yspeed > 0){	//Si está bajanado					yspeed = -monster.y;	//le quito lo que me queda por llegar al suelo				}else{					yspeed = 0;	//Si ya estaba en el suelo, le dejo en el suelo.				}			}			//Sky boundary						if(yspeed<-220-monster.y){	//Si le vamos a subir más de lo que queda por llegar al cielo 				if(yspeed < 0){	//Si está subiendo					yspeed = -220-monster.y;	//le quito lo que me queda por llegar al techo					jumping = true;				}else{					yspeed = 0;	//Si ya estaba en el cielo, le dejo en el suelo.				}				}			/*			if(monster.y < -220 && yspeed<0){				yspeed=0;				jumping = true;			}*/			//Sides boundary			if(xspeed>44-monster.x){	//Si le vamos a mover a la derecha más de lo que queda por llegar al borde 				if(xspeed > 0){	//Si está yendo a la derecha					xspeed = 44-monster.x;	//le quito lo que me queda por llegar al borde				}else{					xspeed = 0;	//Si ya estaba en el cielo, le dejo en el suelo.				}				}			var f:int = 44-monster.x;			if(xspeed<-371.75-monster.x){	//Si le vamos a mover a la izquierda más de lo que queda por llegar al borde 				if(xspeed < 0){	//Si está yendo a la izquierda					xspeed = -371.75-monster.x;	//le quito lo que me queda por llegar al borde				}else{					xspeed = 0;	//Si ya estaba en el cielo, le dejo en el suelo.				}				}			/*			if(monster.x > 44 && xspeed>0){				xspeed=0;			}			if (monster.x<-371.75 && xspeed<0){				xspeed=0;			}*/						//After all checks, we move the character			monster.y += yspeed;			monster.x += xspeed;		}				function cocoFalls(event:Event):void {			if (coco_falling && coco.y<375){				coco.fall();							}else{				//If the coco is falling but reaches the floor, we raised the coco_calling = false flag				coco_falling = false				//If the coco has reached the floor and it hasn't been eaten, we mark it as added = false so we can add a new one				if (coco.y>=375){					coco_added = false;				}			}		}		}	}